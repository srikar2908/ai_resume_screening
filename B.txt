1.round robin

#include<stdio.h>
int main(){
	
	int n,tq,i,time=0,remaining,bt[10],wt[10],tat[10],rt[10];
	float avgwt=0,avgtat=0;
	
	printf("\nEnter No of Process : ");
	scanf("%d",&n);
	
	printf("\nEnter Burst Times Of the Process:");
	
	for(i=0;i<n;i++){
		printf("\np%d :  ",i+1);
		scanf("%d",&bt[i]);
		rt[i] = bt[i];
	}
	
		printf("\nEnter Time Quantum:");
		scanf("%d",&tq);
		
		remaining=n;
		printf("\nGantt Chart : ");
		printf("|");
		
		while(remaining!=0){
			for(i=0;i<n;i++){
				if(rt[i]>0){
					printf(" p%d|",i+1);
					if(rt[i] > tq){
						time += tq;
						rt[i] -= tq;
					}
					else{
						time += rt[i];
						tat[i] = time;
						wt[i] = tat[i] - bt[i];
						rt[i] = 0;
						remaining--;
					}
				}
			}
		}
		
		printf("\n0");
		remaining=n;
		time=0;
		for(i=0;i<n;i++)rt[i]=bt[i];
		while(remaining!=0){
			for(i=0;i<n;i++){
				if(rt[i]>0){
					if(rt[i] > tq){
						time += tq;
						rt[i] -= tq;
						printf(" %d",time);
					}
					else{
						time += rt[i];
						rt[i] = 0;
						printf(" %d",time);
						remaining--;
					}
				}
			}
		}
		
		printf("\n\nProcess\tBurst Time\tWaiting Time\tTurn Around Time");
		for(i=0;i<n;i++){
			printf("\nP%d\t%d\t%d\t%d",i+1,bt[i],wt[i],tat[i]);
			avgwt += wt[i];
			avgtat += tat[i];
		}
		avgwt/=n;
		avgtat/=n;
		
		printf("Average Waiting Time is %.2f",avgwt);
		printf("Average Turn Around Time is %.2f",avgtat);
	
	return 0;
		
	
}
-------------------------------------------------------------------------------------

2.priority

#include<stdio.h>
int main(){
	
	int n,i,j,time=0,bt[10],wt[10],tat[10],pr[10],p[10],pos,temp;
	float avgwt=0,avgtat=0;
	
	printf("\nEnter No of Process : ");
	scanf("%d",&n);
	
	printf("\nEnter Burst Time And Priority Of each Process:");
	
	for(i=0;i<n;i++){
		printf("\np%d :  ",i+1);
		scanf("%d",&bt[i]);
		printf("\n Priority for p%d :",i+1);
		scanf("%d",&pr[i]);
		p[i] = i+1;	
	}
	
	for(i=0;i<n-1;i++){
		pos=i;
		for(j=i+1;j<n;j++){
			if(pr[j]<pr[pos])
			{
				pos=j;
			}
			
		}
			temp = pr[i];pr[i] = pr[pos]; pr[pos] = temp;
			temp = bt[i];bt[i] = bt[pos]; bt[pos] = temp;
			temp = p[i];p[i] = p[pos]; p[pos] = temp;
	}
	
	wt[0] = 0;
	for(i=1;i<n;i++){
		wt[i] = wt[i-1] + bt[i-1];
		avgwt += wt[i];
	}
	
	for(i=0;i<n;i++){
		tat[i] = wt[i] + bt[i];
		avgtat += tat[i];
	}
	
	printf("\n Gantt Chart : ");
	for(i=0;i<n;i++){
		printf("|p%d",p[i]);
	}
	printf("\n0");
	for(i=0;i<n;i++){
		time += bt[i];
		printf("  %d",time);
	}
	
	printf("\n\nProcess\tPriority\tBurst Time\tWaiting Time\tTurn Around Time");
		for(i=0;i<n;i++){
			printf("\nP%d\t%d\t%d\t%d\t%d",p[i],pr[i],bt[i],wt[i],tat[i]);
		}
		avgwt/=n;
		avgtat/=n;
		
		printf("Average Waiting Time is %.2f",avgwt);
		printf("Average Turn Around Time is %.2f",avgtat);
	
	return 0;
}
-------------------------------------------------------------------------------------------------
3.sjf

#include<stdio.h>
int main(){
	
	int n,i,j,time=0,bt[10],wt[10],tat[10],p[10],pos,temp;
	float avgwt=0,avgtat=0;
	
	printf("\nEnter No of Process : ");
	scanf("%d",&n);
	
	printf("\nEnter Burst Time  Of each Process:");
	
	for(i=0;i<n;i++){
		printf("\np%d :  ",i+1);
		scanf("%d",&bt[i]);
		p[i] = i+1;	
	}
	
	for(i=0;i<n-1;i++){
		pos=i;
		for(j=i+1;j<n;j++){
			if(bt[j]<bt[pos])
			{
				pos=j;
			}
			
		}
			temp = bt[i];bt[i] = bt[pos]; bt[pos] = temp;
			temp = p[i];p[i] = p[pos]; p[pos] = temp;
	}
	
	wt[0] = 0;
	for(i=1;i<n;i++){
		wt[i] = wt[i-1] + bt[i-1];
		avgwt += wt[i];
	}
	
	for(i=0;i<n;i++){
		tat[i] = wt[i] + bt[i];
		avgtat += tat[i];
	}
	
	printf("\n Gantt Chart : ");
	for(i=0;i<n;i++){
		printf("|p%d",p[i]);
	}
	printf("\n0");
	for(i=0;i<n;i++){
		time += bt[i];
		printf("  %d",time);
	}
	
	printf("\n\nProcess\tBurst Time\tWaiting Time\tTurn Around Time");
		for(i=0;i<n;i++){
			printf("\nP%d\t%d\t%d\t%d",p[i],bt[i],wt[i],tat[i]);
		}
		avgwt/=n;
		avgtat/=n;
		
		printf("Average Waiting Time is %.2f",avgwt);
		printf("Average Turn Around Time is %.2f",avgtat);
	
	return 0;
}
	
	
---------------------------------------------------------------------------------------------------

4.fcfs

#include<stdio.h>
int main(){
	
	int n,i,time=0,bt[10],wt[10],tat[10];
	float avgwt=0,avgtat=0;
	
	printf("\nEnter No of Process : ");
	scanf("%d",&n);
	
	printf("\nEnter Burst Time  Of each Process:");
	
	for(i=0;i<n;i++){
		printf("\np%d :  ",i+1);
		scanf("%d",&bt[i]);	
	}
	
	
	wt[0] = 0;
	for(i=1;i<n;i++){
		wt[i] = wt[i-1] + bt[i-1];
		avgwt += wt[i];
	}
	
	for(i=0;i<n;i++){
		tat[i] = wt[i] + bt[i];
		avgtat += tat[i];
	}
	
	printf("\n Gantt Chart : ");
	for(i=0;i<n;i++){
		printf("p%d|",i+1);
	}
	printf("\n0");
	for(i=0;i<n;i++){
		time += bt[i];
		printf("  %d",time);
	}
	
	printf("\n\nProcess\tBurst Time\tWaiting Time\tTurn Around Time");
		for(i=0;i<n;i++){
			printf("\nP%d\t%d\t%d\t%d",i+1,bt[i],wt[i],tat[i]);
		}
		avgwt/=n;
		avgtat/=n;
		
		printf("Average Waiting Time is %.2f",avgwt);
		printf("Average Turn Around Time is %.2f",avgtat);
	
	return 0;
}
	
	


---------------------------------------------------------------------------------------------------------------------------------	
ports 

#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#include<semaphore.h>

#define MAX_PORTS 2
#define TOTAL_PROCESSES 4

sem_t ports;
void* use_ports(void* arg){
	int id = *(int*)arg;
	
	printf("\nProcess %d is Waiting for a port...",id);
	sem_wait(&ports);
	printf("\nProcess %d is opened on  port...",id);
	sleep(2);
	printf("\nProcess %d is closed on  port...",id);
	sem_post(&ports);
	return NULL;	
}

int main(){
	pthread_t t[TOTAL_PROCESSES];
	int id[TOTAL_PROCESSES],i;
	sem_init(&ports,0,MAX_PORTS);
	
	for(i=0;i<TOTAL_PROCESSES;i++){
		pthread_create(&t[i],NULL,use_ports,&id[i]);
		id[i] = i+1;
		sleep(1);
	}
	for(i=0;i<TOTAL_PROCESSES;i++){
		pthread_join(t[i],NULL);
		
	}
	printf("\n All Processes Finished.....");
	sem_destroy(&ports);
	return 0;
}


#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#define MAX_PORTS 2
#define TOTAL_PROCESSES 5

int ports = MAX_PORTS;
pthread_mutex_t lock;
pthread_cond_t cond;

void* use_ports(void* arg){
	int id = *(int*)arg;
	pthread_mutex_lock(&lock);
	while(ports==0){
	printf("\n Process %d waiting for port",id);
	pthread_cond_wait(&cond,&lock);
	}
	
	ports--;
	printf("\n Process %d opened a port , available ports : %d",id,ports);
	pthread_mutex_unlock(&lock);
	sleep(2);
	
	pthread_mutex_lock(&lock);
	ports++;
	printf("\n Process %d closed on port , available port : %d",id,ports);
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&lock);
	return NULL;
}

int main(){
	pthread_t t[TOTAL_PROCESSES];
	int id[TOTAL_PROCESSES],i;
	pthread_mutex_init(&lock,NULL);
	pthread_cond_init(&cond,NULL);
	
	for(i=0;i<TOTAL_PROCESSES;i++){
		id[i] = i+1;
		pthread_create(&t[i],NULL,use_ports,&id[i]);
		sleep(1);
	}
	for(i=0;i<TOTAL_PROCESSES;i++){
		pthread_join(t[i],NULL);
	}
	printf("\nAll Processes Finished....");
	pthread_mutex_destroy(&lock);
	pthread_cond_destroy(&cond);
	return 0;
}

--------------------------------------------------------------------------------------------------
producer consumer and dining philosophers


#include<stdio.h>
#include<unistd.h>
#include<semaphore.h>
#include<pthread.h>

#define SIZE 5

int buffer[SIZE];
int in=0,out=0;
sem_t empty,full;
pthread_mutex_t mutex;

void* producer(void* arg){
	int i;
	for(i=1;i<=10;i++){
		sem_wait(&empty);
		pthread_mutex_lock(&mutex);
		
		buffer[in] = i;
		printf("\n Producer Produced %d at pos %d",i,in);
		in = (in + 1)%SIZE;
		
			pthread_mutex_unlock(&mutex);
			sem_post(&full);
		sleep(1);	
	}
	return NULL;
}

void* consumer(void* arg){
	int i;
	for(i=1;i<=10;i++){
		int item;
		sem_wait(&full);
		pthread_mutex_lock(&mutex);
		
		item = buffer[out];
		printf("\n Consumer Consumed %d at pos %d",i,out);
		out = (out + 1) % SIZE;
		
			pthread_mutex_unlock(&mutex);
			sem_post(&empty);
		sleep(1);	
	}
	return NULL;
}

int main(){
	pthread_t p,c;
	sem_init(&empty,0,SIZE);
	sem_init(&full,0,0);
	pthread_mutex_init(&mutex,NULL);
	
	pthread_create(&p,NULL,producer,NULL);
	pthread_create(&c,NULL,consumer,NULL);
	
	pthread_join(p,NULL);
	pthread_join(c,NULL);
	
	sem_destroy(&empty);
	sem_destroy(&full);
	pthread_mutex_destroy(&mutex);
	
	printf("\n\nAll items Produced And Consumed....");
	return 0;
}

#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#include<semaphore.h>

#define N 4

sem_t chop[N];
void* dine(void* arg){
	int id = *(int*)arg;
	
	printf("\n  Philosoper %d is Thinking..",id);
	sem_wait(&chop[id]);
	sem_wait(&chop[(id + 1)% N]);
	
	sleep(1);
	
	printf("\n  Philosoper %d is Eating..",id);
	sem_post(&chop[id]);
	sem_post(&chop[(id + 1)% N]);
	return NULL;
}

int main(){
	pthread_t t[N];
	int id[N],i;
	for(i=0;i<N;i++){
		sem_init(&chop[i],0,1);	
	}
	for(i=0;i<N;i++){
		id[i] = i;
		pthread_create(&t[i],NULL,dine,&id[i]);
		sleep(1);
	}
	for(i=0;i<N;i++){
		pthread_join(t[i],NULL);
	}
	
	printf("\n All philosophers dinned....");
	for(i=0;i<N;i++){
		sem_destroy(&chop[i]);
	}
	return 0;
}
	

--------------------------------------------------------------------------------------------------

bankers alg


#include <stdio.h>

int main() {
    int n, m, i, j, k;
    int alloc[10][10], max[10][10], need[10][10];
    int avail[10], finish[10], safe[10];
    int count = 0, flag, found;

    printf("Enter number of processes: ");
    scanf("%d", &n);
    printf("Enter number of resources: ");
    scanf("%d", &m);

    printf("Enter Allocation Matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("Enter Maximum Matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    printf("Enter Available Resources:\n");
    for (i = 0; i < m; i++)
        scanf("%d", &avail[i]);

    // Calculate Need Matrix
    printf("\nNeed Matrix:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            need[i][j] = max[i][j] - alloc[i][j];
            printf("%d\t", need[i][j]);
        }
        printf("\n");
    }

    for (i = 0; i < n; i++)
        finish[i] = 0;

    // Main Banker's Algorithm
    while (count < n) {
        found = 0; // whether any process ran in this cycle

        for (i = 0; i < n; i++) {
            if (finish[i] == 0) {
                flag = 1;
                for (j = 0; j < m; j++) {
                    if (need[i][j] > avail[j]) {
                        flag = 0;
                        break;
                    }
                }

                if (flag == 1) { // process can execute
                    for (k = 0; k < m; k++)
                        avail[k] += alloc[i][k];

                    safe[count++] = i;
                    finish[i] = 1;
                    found = 1;
                }
            }
        }

        if (found == 0) {
            printf("\nSystem is in an UNSAFE state!\n");
            return 0;
        }
    }

    printf("\nSystem is in a SAFE state.\nSafe Sequence: ");
    for (i = 0; i < n; i++) {
        printf("P%d", safe[i]);
        if (i != n - 1)
            printf(" -> ");
    }
    printf("\n");

    return 0;
}
-------------------------------------------------------------------------------------------------------------------


first fit,bestfit,worstfit


#include <stdio.h>

int main() {
    int nb = 5; // number of memory blocks
    int np = 4; // number of processes

    int b[10] = {100, 500, 200, 300, 600}; // block sizes
    int p[10] = {212, 417, 112, 426};      // process sizes
    int alloc[10];
    int i, j;

    // Initialize allocation array (-1 means not allocated)
    for (i = 0; i < np; i++)
        alloc[i] = -1;

    // First Fit Allocation
    for (i = 0; i < np; i++) {
        for (j = 0; j < nb; j++) {
            if (b[j] >= p[i]) {  // block fits process
                alloc[i] = j;    // assign block j to process i
                b[j] -= p[i];    // reduce remaining block size
                break;           // move to next process
            }
        }
    }

    // Display allocation results
    printf("First Fit Memory Allocation:\n");
    printf("\nProcess No.\tProcess Size\tBlock No.\n");
    for (i = 0; i < np; i++) {
        if (alloc[i] != -1)
            printf("%d\t\t%d\t\t%d\n", i + 1, p[i], alloc[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, p[i]);
    }

    return 0;
}
0


#include <stdio.h>

int main() {
    int nb = 5, np = 4;
    int b[10] = {100, 500, 200, 300, 600}; // Block sizes
    int p[10] = {212, 417, 112, 426};      // Process sizes
    int alloc[10];
    int i, j, best;

    for (i = 0; i < np; i++) alloc[i] = -1;

    for (i = 0; i < np; i++) {
        best = -1;
        for (j = 0; j < nb; j++) {
            if (b[j] >= p[i]) {
                if (best == -1 || b[j] < b[best])
                    best = j; // smallest fitting block
            }
        }

        if (best != -1) {
            alloc[i] = best;
            b[best] -= p[i];
        }
    }

    printf("---- Best Fit Allocation ----\n");
    printf("Process No.\tProcess Size\tBlock No.\n");
    for (i = 0; i < np; i++) {
        if (alloc[i] != -1)
            printf("%d\t\t%d\t\t%d\n", i + 1, p[i], alloc[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, p[i]);
    }

    return 0;
}



#include <stdio.h>

int main() {
    int nb = 5, np = 4;
    int b[10] = {100, 500, 200, 300, 600}; // Block sizes
    int p[10] = {212, 417, 112, 426};      // Process sizes
    int alloc[10];
    int i, j, worst;

    for (i = 0; i < np; i++) alloc[i] = -1;

    for (i = 0; i < np; i++) {
        worst = -1;
        for (j = 0; j < nb; j++) {
            if (b[j] >= p[i]) {
                if (worst == -1 || b[j] > b[worst])
                    worst = j; // largest fitting block
            }
        }

        if (worst != -1) {
            alloc[i] = worst;
            b[worst] -= p[i];
        }
    }

    printf("---- Worst Fit Allocation ----\n");
    printf("Process No.\tProcess Size\tBlock No.\n");
    for (i = 0; i < np; i++) {
        if (alloc[i] != -1)
            printf("%d\t\t%d\t\t%d\n", i + 1, p[i], alloc[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, p[i]);
    }

    return 0;
}
---------------------------------------------------------
page replacement algo using fifo
#include <stdio.h>

int main() {
    int i, j, n, f;
    int page[50];         // Array to store the page reference string
    int frame[10];        // Array to represent the physical memory frames
    int count = 0;        // Used as the 'pointer' to track the frame to be replaced next (FIFO logic)
    int pageFaults = 0;   // Counter for the total number of page faults

    // --- 1. Input ---
    printf("Enter the number of pages: ");
    scanf("%d", &n);

    printf("Enter the reference string (page numbers):\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &page[i]);
    }

    printf("Enter the number of frames: ");
    scanf("%d", &f);

    // Initialize frames to -1 (empty state)
    for (i = 0; i < f; i++)
        frame[i] = -1;

    printf("\nPage\tFrames\t\tStatus\n");

    // --- 2. FIFO Simulation ---
    for (i = 0; i < n; i++) {
        int flag = 0; // flag = 0 means Page Fault (page not found)

        // Check if the current page is already in a frame (Hit)
        for (j = 0; j < f; j++) {
            if (frame[j] == page[i]) {
                flag = 1; // Page hit!
                break;
            }
        }

        // If page not found (flag == 0) -> Page Fault occurs
        if (flag == 0) {
            // Replace the page at the 'count' index (FIFO replacement)
            frame[count] = page[i];

            // Move the count pointer to the next frame in a circular fashion (0, 1, 2, ..., f-1, 0, ...)
            count = (count + 1) % f;

            pageFaults++;
        }

        // --- 3. Output Current State ---
        printf("%d\t", page[i]);
        for (j = 0; j < f; j++) {
            if (frame[j] != -1)
                printf("%d ", frame[j]);
            else
                printf("- "); // Print '-' for an empty frame
        }

        if (flag == 0)
            printf("\tPage Fault\n");
        else
            printf("\tNo Fault\n");
    }

    // --- 4. Final Result ---
    printf("\nTotal Page Faults = %d\n", pageFaults);
    
    return 0;
}
---------------------------------------------------------
page replacement algo using lru
#include <stdio.h>

int main() {
    // Variable Declaration
    int n, f;                   // n: number of pages, f: number of frames
    int pages[50];              // Page reference string
    int frame[10];              // Physical memory frames
    int counter[10];            // Tracks last access time for LRU
    int i, j, k;                // Loop counters
    int pageFaults = 0;         // Total page faults count
    int flag1, flag2;           // Flag1: Page Hit/Fault, Flag2: Empty Frame Check
    int min, pos;               // min: minimum counter value, pos: position of LRU page

    // --- 1. Input ---
    printf("Enter the number of pages: ");
    scanf("%d", &n);
    
    printf("Enter the reference string (page numbers):\n");
    for (i = 0; i < n; i++)
        scanf("%d", &pages[i]);
    
    printf("Enter the number of frames: ");
    scanf("%d", &f);
    
    // Initialize frames and counters
    for (i = 0; i < f; i++) {
        frame[i] = -1;  // -1 indicates an empty frame
        counter[i] = 0; // Initialize last access time
    }
    
    printf("\nPage\tFrames\t\tStatus\n");
    
    // --- 2. LRU Simulation Loop ---
    for (i = 0; i < n; i++) {
        flag1 = flag2 = 0;
        
        // A. Check for Page Hit
        for (j = 0; j < f; j++) {
            if (frame[j] == pages[i]) {
                counter[j] = i + 1; // UPDATE: Mark as Most Recently Used
                flag1 = flag2 = 1;  // Page Hit!
                break;
            }
        }
        
        // B. Handle Page Fault (Empty Frame Available)
        if (flag1 == 0) {
            for (j = 0; j < f; j++) {
                if (frame[j] == -1) {
                    frame[j] = pages[i];
                    counter[j] = i + 1; // Mark as Most Recently Used
                    flag2 = 1;          // Empty frame used
                    break;
                }
            }
        }
        
        // C. Handle Page Fault (Replacement Needed - All Frames Full)
        if (flag2 == 0) {
            // Find Least Recently Used (LRU) page
            min = counter[0];
            pos = 0;
            for (j = 1; j < f; j++) {
                if (counter[j] < min) { // The lowest counter value is the LRU
                    min = counter[j];
                    pos = j;
                }
            }
            
            // Replace LRU page at position 'pos'
            frame[pos] = pages[i];
            counter[pos] = i + 1; // New page is now MRU
        }
        
        // --- 3. Output Current State ---
        printf("%d\t", pages[i]);
        for (j = 0; j < f; j++) {
            if (frame[j] != -1)
                printf("%d ", frame[j]);
            else
                printf("- ");
        }
        
        if (flag1 == 0)
            printf("\tPage Fault\n");
        else
            printf("\tNo Fault\n");
            
        if (flag1 == 0)
            pageFaults++;
    }
    
    // --- 4. Final Result ---
    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}
------------------------------------------------------------------
page replacement algo using optimal
#include <stdio.h>

int main() {
    // Variable Declaration
    int n, f;                   // n: number of pages, f: number of frames
    int pages[50];              // Page reference string
    int frame[10];              // Physical memory frames
    int future[10];             // Stores the index of the next use for each page in a frame
    int i, j, k;                // Loop counters
    int pageFaults = 0;         // Total page faults count
    int flag1, flag2;           // Flag1: Page Hit/Fault, Flag2: Empty Frame Check
    int pos;                    // Position (index) of the frame to be replaced
    int max;                    // Stores the maximum next use index (farthest future reference)

    // --- 1. Input ---
    printf("Enter the number of pages: ");
    scanf("%d", &n);
    
    printf("Enter the reference string (page numbers):\n");
    for (i = 0; i < n; i++)
        scanf("%d", &pages[i]);
    
    printf("Enter the number of frames: ");
    scanf("%d", &f);
    
    // Initialize frames
    for (i = 0; i < f; i++)
        frame[i] = -1; // -1 indicates an empty frame
    
    printf("\nPage\tFrames\t\tStatus\n");
    
    // --- 2. Optimal Simulation Loop ---
    for (i = 0; i < n; i++) {
        flag1 = flag2 = 0;
        
        // A. Check for Page Hit (Page is already in a frame)
        for (j = 0; j < f; j++) {
            if (frame[j] == pages[i]) {
                flag1 = flag2 = 1; // Page Hit! No replacement needed.
                break;
            }
        }
        
        // B. Handle Page Fault (Empty Frame Available)
        if (flag1 == 0) {
            for (j = 0; j < f; j++) {
                if (frame[j] == -1) {
                    frame[j] = pages[i];
                    flag2 = 1; // Empty frame used
                    pageFaults++;
                    break;
                }
            }
        }
        
        // C. Handle Page Fault (Replacement Needed - All Frames Full)
        if (flag2 == 0) {
            // Determine future usage for all pages currently in frames
            for (j = 0; j < f; j++) {
                future[j] = -1; // Default: page is not used again
                for (k = i + 1; k < n; k++) {
                    if (frame[j] == pages[k]) {
                        future[j] = k; // Record the index of next use
                        break;
                    }
                }
            }
            
            // Find the Optimal Victim Page
            pos = -1;
            max = -1;
            for (j = 0; j < f; j++) {
                if (future[j] == -1) { // 1. Page will NEVER be used again (Highest Priority)
                    pos = j;
                    break;
                } else if (future[j] > max) { // 2. Page used FARTHEST in the future
                    max = future[j];
                    pos = j;
                }
            }
            
            // Replace the Optimal Victim page at position 'pos'
            frame[pos] = pages[i];
            pageFaults++;
        }
        
        // --- 3. Output Current State ---
        printf("%d\t", pages[i]);
        for (j = 0; j < f; j++) {
            if (frame[j] != -1)
                printf("%d ", frame[j]);
            else
                printf("- ");
        }
        
        if (flag1 == 0)
            printf("\tPage Fault\n");
        else
            printf("\tNo Fault\n");
    }
    
    // --- 4. Final Result ---
    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}