fcfs

#include <stdio.h>

int main() {
    int n, i;
    int bt[20], wt[20], tat[20];
    float avgwt = 0, avgtat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    printf("Enter burst time for each process:\n");
    for (i = 0; i < n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &bt[i]);
    }

    wt[0] = 0;  // Waiting time for first process is 0

    // Calculate waiting time
    for (i = 1; i < n; i++) {
        wt[i] = 0;
        for (int j = 0; j < i; j++)
            wt[i] += bt[j];
        avgwt += wt[i];
    }

    // Calculate turnaround time
    printf("\nGantt Chart:\n|");
    for (i = 0; i < n; i++) {
        printf(" P%d |", i + 1);
        tat[i] = bt[i] + wt[i];
        avgtat += tat[i];
    }

    // Print Gantt Chart timing
    printf("\n0");
    int total = 0;
    for (i = 0; i < n; i++) {
        total += bt[i];
        printf(" %d", total);
    }

    avgwt /= n;
    avgtat /= n;

    // Display results
    printf("\n\nProcess\tBurst\tWaiting\tTurnaround\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\n", i + 1, bt[i], wt[i], tat[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avgwt);
    printf("\nAverage Turnaround Time: %.2f\n", avgtat);

    return 0;
}
----------------------------------------------------------------------
sjf

#include <stdio.h>

int main() {
    int n, bt[20], p[20], wt[20], tat[20];
    int i, j, pos, temp;
    float avgwt = 0, avgtat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    printf("Enter burst time for each process:\n");
    for (i = 0; i < n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &bt[i]);
        p[i] = i + 1;  // Process ID
    }

    // Sort based on burst time (SJF)
    for (i = 0; i < n; i++) {
        pos = i;
        for (j = i + 1; j < n; j++) {
            if (bt[j] < bt[pos])
                pos = j;
        }

        temp = bt[i];
        bt[i] = bt[pos];
        bt[pos] = temp;

        temp = p[i];
        p[i] = p[pos];
        p[pos] = temp;
    }

    wt[0] = 0;

    // Waiting time calculation
    for (i = 1; i < n; i++) {
        wt[i] = 0;
        for (j = 0; j < i; j++)
            wt[i] += bt[j];
        avgwt += wt[i];
    }

    // Gantt Chart
    printf("\nGantt Chart:\n|");
    for (i = 0; i < n; i++) {
        printf(" P%d |", p[i]);
        tat[i] = bt[i] + wt[i];
        avgtat += tat[i];
    }

    // Timing line
    printf("\n0");
    int total = 0;
    for (i = 0; i < n; i++) {
        total += bt[i];
        printf(" %d", total);
    }

    avgwt /= n;
    avgtat /= n;

    // Results
    printf("\n\nProcess\tBurst\tWaiting\tTurnaround\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\n", p[i], bt[i], wt[i], tat[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avgwt);
    printf("\nAverage Turnaround Time: %.2f\n", avgtat);

    return 0;
}
------------------------------------------------------------------------------------------
priority

#include <stdio.h>

int main() {
    int n, bt[20], p[20], wt[20], tat[20],pr[20];
    int i, j, pos, temp;
    float avgwt = 0, avgtat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    printf("Enter burst time and priority for each process:\n");
    for (i = 0; i < n; i++) {
        printf("burst time P%d: ", i + 1);
        scanf("%d", &bt[i]);
        printf("priority P%d: ", i + 1);
        scanf("%d", &pr[i]);
        p[i] = i + 1;  // Process ID
    }

    // Sort based on pripority
    for (i = 0; i < n; i++) {
        pos = i;
        for (j = i + 1; j < n; j++) {
            if (pr[j] < pr[pos])
                pos = j;
        }

        temp = bt[i];
        bt[i] = bt[pos];
        bt[pos] = temp;
        
        temp = pr[i];
        pr[i] = pr[pos];
        pr[pos] = temp;

        temp = p[i];
        p[i] = p[pos];
        p[pos] = temp;
    }

    wt[0] = 0;

    // Waiting time calculation
    for (i = 1; i < n; i++) {
        wt[i] = 0;
        for (j = 0; j < i; j++)
            wt[i] += bt[j];
        avgwt += wt[i];
    }

    // Gantt Chart
    printf("\nGantt Chart:\n|");
    for (i = 0; i < n; i++) {
        printf(" P%d |", p[i]);
        tat[i] = bt[i] + wt[i];
        avgtat += tat[i];
    }

    // Timing line
    printf("\n0");
    int total = 0;
    for (i = 0; i < n; i++) {
        total += bt[i];
        printf(" %d", total);
    }

    avgwt /= n;
    avgtat /= n;

    // Results
    printf("\n\nProcess\tpriority\tBurst\tWaiting\tTurnaround\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n", p[i],pr[i], bt[i], wt[i], tat[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avgwt);
    printf("\nAverage Turnaround Time: %.2f\n", avgtat);

    return 0;
}
------------------------------------------------------------------------------------------------
round robin

#include <stdio.h>

int main() {
    int n, i, tq, time = 0;
    int bt[20], rem[20], wt[20], tat[20];
    float avgwt = 0, avgtat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    printf("Enter burst times:\n");
    for (i = 0; i < n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &bt[i]);
        rem[i] = bt[i];
    }

    printf("Enter Time Quantum: ");
    scanf("%d", &tq);

    printf("\nGantt Chart:\n|");
    
    int gantt[200];   // store time points
    int gp = 0;
    gantt[gp++] = 0;

    while (1) {
        int done = 1;

        for (i = 0; i < n; i++) {
            if (rem[i] > 0) {
                done = 0;

                printf(" P%d |", i + 1);

                if (rem[i] > tq) {
                    time += tq;
                    rem[i] -= tq;
                } else {
                    time += rem[i];
                    wt[i] = time - bt[i];
                    rem[i] = 0;
                }

                gantt[gp++] = time;
            }
        }

        if (done)
            break;
    }

    // Turnaround time
    for (i = 0; i < n; i++) {
        tat[i] = bt[i] + wt[i];
        avgwt += wt[i];
        avgtat += tat[i];
    }

    avgwt /= n;
    avgtat /= n;

    // Print timeline
    printf("\n");
    for (i = 0; i < gp; i++) {
        printf("%d ", gantt[i]);
    }

    // Final table
    printf("\n\nProcess\tBurst\tWaiting\tTurnaround\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\n", i + 1, bt[i], wt[i], tat[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avgwt);
    printf("\nAverage Turnaround Time: %.2f\n", avgtat);

    return 0;
}
---------------------------------------------------------------------------
pthreads code

#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<unistd.h>
void* task1(void *arg)
{
	int i;
	for(i=1;i<6;i++)
	{
	printf("\nthread 1:counting %d",i);
	sleep(1);
	}
	pthread_exit(NULL);
}

void* task2(void* arg)
{
	int i;
	for(i=1;i<6;i++)
	{
	printf("\nthread 2:counting %d",i);
	sleep(1);
	}
	pthread_exit(NULL);
}
int main()
{
	pthread_t t1,t2;
	printf("creating threaads...");
	pthread_create(&t1,NULL,task1,NULL);
	pthread_create(&t2,NULL,task2,NULL);
	pthread_join(t1,NULL);
	pthread_join(t2,NULL);
	printf("\nboth threads executed sucessfully");
	return 0;
}
--------------------------------------------------------------------------------
producer consumer

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 5   
int buffer[BUFFER_SIZE];
int in = 0, out = 0;     
sem_t empty;
sem_t full;              
pthread_mutex_t mutex;    

void *producer(void *arg) {

    for (int i = 1; i <= 10; i++) {   
        item = i;

        sem_wait(&empty);             
        pthread_mutex_lock(&mutex);  

        buffer[in] = item;
        printf("Producer produced item %d at position %d\n", item, in);

        in = (in + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex);
        sem_post(&full);              

        sleep(1);
    }

    return NULL;
}

void *consumer(void *arg) {
    int item;

    for (int i = 1; i <= 10; i++) {   
        sem_wait(&full);              
        pthread_mutex_lock(&mutex);   

        item = buffer[out];
        printf("Consumer consumed item %d from position %d\n", item, out);

        out = (out + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex);
        sem_post(&empty);            

        sleep(2);
    }

    return NULL;
}

int main() {
    pthread_t prod_thread, cons_thread;

    sem_init(&empty, 0, BUFFER_SIZE);  
    sem_init(&full, 0, 0);             
    pthread_mutex_init(&mutex, NULL);

    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    printf("\nAll items produced and consumed successfully.\n");

    return 0;
}
--------------------------------------------------------------------------
philosphers

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define N 5  // Number of philosophers

sem_t chopstick[N];  // One chopstick per philosopher

void *philosopher(void *num) {
    int id = *(int *)num;

    printf("Philosopher %d is thinking...\n", id);
    sleep(1);
    sem_wait(&chopstick[id]);                 
    sem_wait(&chopstick[(id + 1) % N]);       

    printf("Philosopher %d is eating...\n", id);
    sleep(2);
    sem_post(&chopstick[id]);                 
    sem_post(&chopstick[(id + 1) % N]);       
    printf("Philosopher %d finished eating and left the table.\n", id);

    return NULL;
}

int main() {
    pthread_t thread_id[N];
    int philosophers[N];
    for (int i = 0; i < N; i++) {
        sem_init(&chopstick[i], 0, 1);
    }
    for (int i = 0; i < N; i++) {
        philosophers[i] = i;
        pthread_create(&thread_id[i], NULL, philosopher, &philosophers[i]);
        sleep(1);  // Small delay to reduce deadlock chances
    }
    for (int i = 0; i < N; i++) {
        pthread_join(thread_id[i], NULL);
    }
    for (int i = 0; i < N; i++) {
        sem_destroy(&chopstick[i]);
    }
    printf("\nAll philosophers have finished dining.\n");
    return 0;
}
---------------------------------------------------------------------------------------------
ports semaphore

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define MAX_PORTS 3
#define TOTAL_PROCESSES 8

sem_t portSemaphore;

void* open_port(void* process_id) {
    int id = *(int*)process_id;
    printf("Process %d is waiting to open a port...\n", id);

    sem_wait(&portSemaphore);

    printf("Process %d has opened a port.\n", id);
    sleep(2);

    printf("Process %d is closing the port.\n", id);
    sem_post(&portSemaphore);

    return NULL;
}


int main() {
    pthread_t threads[TOTAL_PROCESSES];
    int process_ids[TOTAL_PROCESSES];
    int i;
    sem_init(&portSemaphore, 0, MAX_PORTS);

    for (i = 0; i < TOTAL_PROCESSES; i++) {
        process_ids[i] = i + 1;
        pthread_create(&threads[i], NULL, open_port, &process_ids[i]);
        sleep(1);
    }

    for (i = 0; i < TOTAL_PROCESSES; i++) {
        pthread_join(threads[i], NULL);
    }

    sem_destroy(&portSemaphore);

    printf("\nAll processes have completed.\n");

    return 0;
}
----------------------------------------------------------------------------
ports monitor

#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#define maxports 2
#define totalprocess 5
int availports=maxports;
pthread_mutex_t lock;
pthread_cond_t cond;
void* openport(void *pid)
{
	int id=*(int*)pid;
	pthread_mutex_lock(&lock);
	while(availports==0)
	{
		printf("process %d waiting for a port\n",id);
		pthread_cond_wait(&cond,&lock);
	}
	availports-=1;
	printf("process %d opened a port,remaining ports are %d\n",id,availports);
	pthread_mutex_unlock(&lock);
	sleep(2);
	pthread_mutex_lock(&lock);
	availports+=1;
	printf("process %d closed port, remaining ports are %d\n",id,availports);
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&lock);
	return NULL;
}
int main()
{
	int ids[totalprocess];
	int i;
	pthread_t threads[totalprocess];
	pthread_mutex_init(&lock,NULL);
	pthread_cond_init(&cond,NULL);
	for(i=0;i<totalprocess;i++)
	{
		ids[i]=i+1;
		pthread_create(&threads[i],NULL,&openport,&ids[i]);
		sleep(1);
		
	}
	for(i=0;i<totalprocess;i++)
	{
		pthread_join(threads[i],NULL);
	}
	pthread_mutex_destroy(&lock);
	pthread_cond_destroy(&cond);
	return 0;
}
---------------------------------------------------------------------------------
bankers

#include <stdio.h>

int main() {
    int n, m, i, j, k;
    int alloc[10][10], max[10][10], avail[10];
    int need[10][10], finish[10], safeSeq[10];
    int count = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the number of resource types: ");
    scanf("%d", &m);

    printf("Enter the Allocation Matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("Enter the Maximum Matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    printf("Enter the Available Resources:\n");
    for (i = 0; i < m; i++)
        scanf("%d", &avail[i]);

    // Calculate Need Matrix
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            need[i][j] = max[i][j] - alloc[i][j];

    // Set all finish flags to 0
    for (i = 0; i < n; i++)
        finish[i] = 0;

    printf("\nNeed Matrix:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++)
            printf("%d\t", need[i][j]);
        printf("\n");
    }

    // Banker's Algorithm
    while (count < n) {
        int found = 0;

        for (i = 0; i < n; i++) {
            if (finish[i] == 0) {

                int flag = 0;
                for (j = 0; j < m; j++) {
                    if (need[i][j] > avail[j]) {
                        flag = 1;
                        break;
                    }
                }

                if (flag == 0) {  // If resources can be allocated
                    for (k = 0; k < m; k++)
                        avail[k] += alloc[i][k];

                    safeSeq[count++] = i;
                    finish[i] = 1;
                    found = 1;
                }
            }
        }

        if (found == 0) {
            printf("\nSystem is in an UNSAFE state!\n");
            return 0;
        }
    }

    printf("\nSystem is in a SAFE state.\nSafe Sequence: ");
    for (i = 0; i < n - 1; i++)
        printf("P%d -> ", safeSeq[i]);
    printf("P%d\n", safeSeq[n - 1]);

    return 0;
}
-----------------------------------------------------------------------
firstfit

#include <stdio.h>

int main() {
    // Variable Declaration
    int nb, np;                 // nb: number of blocks, np: number of processes
    int b[10];                  // Array to store memory block sizes
    int p[10];                  // Array to store process sizes
    int allocation[10];         // Stores the allocated block index for each process (-1 if unallocated)
    int i, j;                   // Loop counters

    // --- 1. Input: Memory Blocks ---
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);

    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &b[i]);
    }

    // --- 2. Input: Processes ---
    printf("Enter the number of processes: ");
    scanf("%d", &np);

    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &p[i]);
    }

    // Initialize allocation array (-1 means not allocated)
    for (i = 0; i < np; i++)
        allocation[i] = -1;

    // --- 3. First Fit Allocation Logic ---
    for (i = 0; i < np; i++) { // Iterate through all processes
        for (j = 0; j < nb; j++) { // Iterate through memory blocks
            // Check if the current block (b[j]) is large enough for the process (p[i])
            if (b[j] >= p[i]) {
                allocation[i] = j;      // Allocate process 'i' to block 'j'
                b[j] -= p[i];           // Reduce the available size of the block
                break;                  // Stop searching and move to the next process (FIRST FIT)
            }
        }
    }

    // --- 4. Display Allocation Results ---
    printf("\n--- First Fit Allocation Results ---\n");
    printf("Process No.\tProcess Size\tBlock No.\n");
    
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            // Block index is 'allocation[i]', so block number is 'allocation[i] + 1'
            printf("%d\t\t%d\t\t%d\n", i + 1, p[i], allocation[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, p[i]);
    }

    return 0;
}
---------------------------------------------------------------
bestfit

#include <stdio.h>

int main() {
    // Variable Declaration
    int nb, np;                 // nb: number of blocks, np: number of processes
    int b[10];                  // Array for memory block sizes
    int p[10];                  // Array for process sizes
    int allocation[10];         // Stores allocated block index for each process
    int i, j;                   // Loop counters
    int best;                   // Stores the index of the best (smallest suitable) block

    // --- 1. Input: Memory Blocks ---
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);

    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &b[i]);
    }

    // --- 2. Input: Processes ---
    printf("Enter the number of processes: ");
    scanf("%d", &np);

    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &p[i]);
    }

    // Initialize allocation array (-1 means not allocated)
    for (i = 0; i < np; i++)
        allocation[i] = -1;

    // --- 3. Best Fit Allocation Logic ---
    for (i = 0; i < np; i++) { // Iterate through all processes
        best = -1;             // Reset 'best' block index for the new process

        for (j = 0; j < nb; j++) { // Search for the smallest suitable block
            // 1. Check if the block can fit the process
            if (b[j] >= p[i]) {
                // 2. Check if this is the first suitable block found (best == -1)
                //    OR if this block is smaller than the current 'best' block (b[j] < b[best])
                if (best == -1 || b[j] < b[best])
                    best = j; // Update 'best' to the index of the current block
            }
        }

        if (best != -1) { // If a suitable block was found
            allocation[i] = best;
            b[best] -= p[i]; // Reduce the block size by the process size
        }
    }

    // --- 4. Display Allocation Results ---
    printf("\n--- Best Fit Allocation Results ---\n");
    printf("Process No.\tProcess Size\tBlock No.\n");
    
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            // Block index is 'allocation[i]', so block number is 'allocation[i] + 1'
            printf("%d\t\t%d\t\t%d\n", i + 1, p[i], allocation[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, p[i]);
    }

    return 0;
}
-------------------------------------------------------------------------------
worstfit

#include <stdio.h>

int main() {
    // Variable Declaration
    int nb, np;                 // nb: number of blocks, np: number of processes
    int b[10];                  // Array for memory block sizes
    int p[10];                  // Array for process sizes
    int allocation[10];         // Stores allocated block index for each process
    int i, j;                   // Loop counters
    int worst;                  // Stores the index of the worst (largest suitable) block

    // --- 1. Input: Memory Blocks ---
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);

    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &b[i]);
    }

    // --- 2. Input: Processes ---
    printf("Enter the number of processes: ");
    scanf("%d", &np);

    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &p[i]);
    }

    // Initialize allocation array (-1 means not allocated)
    for (i = 0; i < np; i++)
        allocation[i] = -1;

    // --- 3. Worst Fit Allocation Logic ---
    for (i = 0; i < np; i++) { // Iterate through all processes
        worst = -1;            // Reset 'worst' block index for the new process

        for (j = 0; j < nb; j++) { // Search for the largest suitable block
            // 1. Check if the block can fit the process
            if (b[j] >= p[i]) {
                // 2. Check if this is the first suitable block found (worst == -1)
                //    OR if this block is larger than the current 'worst' block (b[j] > b[worst])
                if (worst == -1 || b[j] > b[worst])
                    worst = j; // Update 'worst' to the index of the current largest block
            }
        }

        if (worst != -1) { // If a suitable block was found
            allocation[i] = worst;
            b[worst] -= p[i]; // Reduce the block size by the process size
        }
    }

    // --- 4. Display Allocation Results ---
    printf("\n--- Worst Fit Allocation Results ---\n");
    printf("Process No.\tProcess Size\tBlock No.\n");
    
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            // Block index is 'allocation[i]', so block number is 'allocation[i] + 1'
            printf("%d\t\t%d\t\t%d\n", i + 1, p[i], allocation[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, p[i]);
    }

    return 0;
}
------------------------------------------------------------------
paging

#include <stdio.h>

int main() {
    // Memory Structure Variables
    int memsize;           // Total logical memory size (in bytes)
    int pagesize;          // Size of each page/frame (in bytes)
    int no_of_pages;       // Calculated number of pages
    int no_of_frames;      // Calculated number of frames (assumed equal to pages)

    // Page Table and Loop Variables
    int frameno[20];       // Array storing Frame No. for each Page No. (the Page Table)
    int page_table[20];    // (Unused in the original code, but kept for exactness)
    int i;                 // Loop counter

    // Address Translation Variables
    int logical_addr;      // Input logical address
    int page_no;           // Calculated page number (P)
    int offset;            // Calculated offset (D)
    int physical_addr;     // Resulting physical address

    // --- 1. Memory Setup Input ---
    printf("Enter the memory size (in bytes): ");
    scanf("%d", &memsize);

    printf("Enter the page size (in bytes): ");
    scanf("%d", &pagesize);

    // Calculate structure parameters
    no_of_pages  = memsize / pagesize;
    no_of_frames = no_of_pages; // assume equal no. of frames

    printf("\nNumber of Pages:  %d", no_of_pages);
    printf("\nNumber of Frames: %d\n", no_of_frames);

    // --- 2. Build Page Table ---
    printf("\nEnter the Frame number where each page is stored:\n");
    for (i = 0; i < no_of_pages; i++) {
        printf("Page %d : ", i);
        scanf("%d", &frameno[i]);
    }

    // Display Page Table
    printf("\nPage Table:\n");
    printf("Page No.\tFrame No.\n");
    for (i = 0; i < no_of_pages; i++)
        printf("%d\t\t%d\n", i, frameno[i]);

    // --- 3. Address Translation ---
    printf("\nEnter a Logical Address (in decimal): ");
    scanf("%d", &logical_addr);

    // Calculate P and D
    page_no = logical_addr / pagesize;
    offset  = logical_addr % pagesize;

    // Validation (Page Boundary Check and Page Fault Check)
    if (page_no >= no_of_pages || frameno[page_no] == -1) {
        printf("Invalid logical address or page not present in memory!\n");
    } else {
        // Calculation: Physical Address = (Frame No. * Page Size) + Offset
        physical_addr = (frameno[page_no] * pagesize) + offset;

        // Display results
        printf("\n--- Address Translation ---\n");
        printf("Page Number      : %d\n", page_no);
        printf("Offset           : %d\n", offset);
        printf("Frame Number     : %d\n", frameno[page_no]);
        printf("Physical Address : %d\n", physical_addr);
    }

    return 0;
}
-----------------------------------------------------------------------
fifo

#include <stdio.h>

int main() {
    int i, j, n, f;
    int page[50];         // Array to store the page reference string
    int frame[10];        // Array to represent the physical memory frames
    int count = 0;        // Used as the 'pointer' to track the frame to be replaced next (FIFO logic)
    int pageFaults = 0;   // Counter for the total number of page faults

    // --- 1. Input ---
    printf("Enter the number of pages: ");
    scanf("%d", &n);

    printf("Enter the reference string (page numbers):\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &page[i]);
    }

    printf("Enter the number of frames: ");
    scanf("%d", &f);

    // Initialize frames to -1 (empty state)
    for (i = 0; i < f; i++)
        frame[i] = -1;

    printf("\nPage\tFrames\t\tStatus\n");

    // --- 2. FIFO Simulation ---
    for (i = 0; i < n; i++) {
        int flag = 0; // flag = 0 means Page Fault (page not found)

        // Check if the current page is already in a frame (Hit)
        for (j = 0; j < f; j++) {
            if (frame[j] == page[i]) {
                flag = 1; // Page hit!
                break;
            }
        }

        // If page not found (flag == 0) -> Page Fault occurs
        if (flag == 0) {
            // Replace the page at the 'count' index (FIFO replacement)
            frame[count] = page[i];

            // Move the count pointer to the next frame in a circular fashion (0, 1, 2, ..., f-1, 0, ...)
            count = (count + 1) % f;

            pageFaults++;
        }

        // --- 3. Output Current State ---
        printf("%d\t", page[i]);
        for (j = 0; j < f; j++) {
            if (frame[j] != -1)
                printf("%d ", frame[j]);
            else
                printf("- "); // Print '-' for an empty frame
        }

        if (flag == 0)
            printf("\tPage Fault\n");
        else
            printf("\tNo Fault\n");
    }

    // --- 4. Final Result ---
    printf("\nTotal Page Faults = %d\n", pageFaults);
    
    return 0;
}
---------------------------------------------------------------------
lru

#include <stdio.h>

int main() {
    // Variable Declaration
    int n, f;                   // n: number of pages, f: number of frames
    int pages[50];              // Page reference string
    int frame[10];              // Physical memory frames
    int counter[10];            // Tracks last access time for LRU
    int i, j, k;                // Loop counters
    int pageFaults = 0;         // Total page faults count
    int flag1, flag2;           // Flag1: Page Hit/Fault, Flag2: Empty Frame Check
    int min, pos;               // min: minimum counter value, pos: position of LRU page

    // --- 1. Input ---
    printf("Enter the number of pages: ");
    scanf("%d", &n);
    
    printf("Enter the reference string (page numbers):\n");
    for (i = 0; i < n; i++)
        scanf("%d", &pages[i]);
    
    printf("Enter the number of frames: ");
    scanf("%d", &f);
    
    // Initialize frames and counters
    for (i = 0; i < f; i++) {
        frame[i] = -1;  // -1 indicates an empty frame
        counter[i] = 0; // Initialize last access time
    }
    
    printf("\nPage\tFrames\t\tStatus\n");
    
    // --- 2. LRU Simulation Loop ---
    for (i = 0; i < n; i++) {
        flag1 = flag2 = 0;
        
        // A. Check for Page Hit
        for (j = 0; j < f; j++) {
            if (frame[j] == pages[i]) {
                counter[j] = i + 1; // UPDATE: Mark as Most Recently Used
                flag1 = flag2 = 1;  // Page Hit!
                break;
            }
        }
        
        // B. Handle Page Fault (Empty Frame Available)
        if (flag1 == 0) {
            for (j = 0; j < f; j++) {
                if (frame[j] == -1) {
                    frame[j] = pages[i];
                    counter[j] = i + 1; // Mark as Most Recently Used
                    flag2 = 1;          // Empty frame used
                    break;
                }
            }
        }
        
        // C. Handle Page Fault (Replacement Needed - All Frames Full)
        if (flag2 == 0) {
            // Find Least Recently Used (LRU) page
            min = counter[0];
            pos = 0;
            for (j = 1; j < f; j++) {
                if (counter[j] < min) { // The lowest counter value is the LRU
                    min = counter[j];
                    pos = j;
                }
            }
            
            // Replace LRU page at position 'pos'
            frame[pos] = pages[i];
            counter[pos] = i + 1; // New page is now MRU
        }
        
        // --- 3. Output Current State ---
        printf("%d\t", pages[i]);
        for (j = 0; j < f; j++) {
            if (frame[j] != -1)
                printf("%d ", frame[j]);
            else
                printf("- ");
        }
        
        if (flag1 == 0)
            printf("\tPage Fault\n");
        else
            printf("\tNo Fault\n");
            
        if (flag1 == 0)
            pageFaults++;
    }
    
    // --- 4. Final Result ---
    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}
-----------------------------------------------------------------------
optimal

#include <stdio.h>

int main() {
    // Variable Declaration
    int n, f;                   // n: number of pages, f: number of frames
    int pages[50];              // Page reference string
    int frame[10];              // Physical memory frames
    int future[10];             // Stores the index of the next use for each page in a frame
    int i, j, k;                // Loop counters
    int pageFaults = 0;         // Total page faults count
    int flag1, flag2;           // Flag1: Page Hit/Fault, Flag2: Empty Frame Check
    int pos;                    // Position (index) of the frame to be replaced
    int max;                    // Stores the maximum next use index (farthest future reference)

    // --- 1. Input ---
    printf("Enter the number of pages: ");
    scanf("%d", &n);
    
    printf("Enter the reference string (page numbers):\n");
    for (i = 0; i < n; i++)
        scanf("%d", &pages[i]);
    
    printf("Enter the number of frames: ");
    scanf("%d", &f);
    
    // Initialize frames
    for (i = 0; i < f; i++)
        frame[i] = -1; // -1 indicates an empty frame
    
    printf("\nPage\tFrames\t\tStatus\n");
    
    // --- 2. Optimal Simulation Loop ---
    for (i = 0; i < n; i++) {
        flag1 = flag2 = 0;
        
        // A. Check for Page Hit (Page is already in a frame)
        for (j = 0; j < f; j++) {
            if (frame[j] == pages[i]) {
                flag1 = flag2 = 1; // Page Hit! No replacement needed.
                break;
            }
        }
        
        // B. Handle Page Fault (Empty Frame Available)
        if (flag1 == 0) {
            for (j = 0; j < f; j++) {
                if (frame[j] == -1) {
                    frame[j] = pages[i];
                    flag2 = 1; // Empty frame used
                    pageFaults++;
                    break;
                }
            }
        }
        
        // C. Handle Page Fault (Replacement Needed - All Frames Full)
        if (flag2 == 0) {
            // Determine future usage for all pages currently in frames
            for (j = 0; j < f; j++) {
                future[j] = -1; // Default: page is not used again
                for (k = i + 1; k < n; k++) {
                    if (frame[j] == pages[k]) {
                        future[j] = k; // Record the index of next use
                        break;
                    }
                }
            }
            
            // Find the Optimal Victim Page
            pos = -1;
            max = -1;
            for (j = 0; j < f; j++) {
                if (future[j] == -1) { // 1. Page will NEVER be used again (Highest Priority)
                    pos = j;
                    break;
                } else if (future[j] > max) { // 2. Page used FARTHEST in the future
                    max = future[j];
                    pos = j;
                }
            }
            
            // Replace the Optimal Victim page at position 'pos'
            frame[pos] = pages[i];
            pageFaults++;
        }
        
        // --- 3. Output Current State ---
        printf("%d\t", pages[i]);
        for (j = 0; j < f; j++) {
            if (frame[j] != -1)
                printf("%d ", frame[j]);
            else
                printf("- ");
        }
        
        if (flag1 == 0)
            printf("\tPage Fault\n");
        else
            printf("\tNo Fault\n");
    }
    
    // --- 4. Final Result ---
    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}
----------------------------------------------------------
